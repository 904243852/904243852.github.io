<!DOCTYPE html>


<html lang="zh">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Linux 命令 |  Dim.Ke
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-linux"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux 命令
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/12/13/linux/" class="article-date">
  <time datetime="2020-12-13T07:41:26.593Z" itemprop="datePublished">2020-12-13</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">12.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">58 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><a id="more"></a>
<ul>
<li><p>常用文件管理命令</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 强制删除目录以及其下所有文件、文件夹（参数 f 表示强制，不推荐使用；参数 r 表示递归删除）</span></span><br><span class="line"><span class="comment"># rm -rf folder</span></span><br><span class="line"><span class="comment"># 递归删除目录</span></span><br><span class="line">rm -r folder</span><br><span class="line"><span class="comment"># 删除文件 hello.txt</span></span><br><span class="line">rm hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 彻底删除、粉碎文件</span></span><br><span class="line">shred -u hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前目录，print working directory(打印工作目录)</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空白的文件</span></span><br><span class="line">touch file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个临时文件（&quot;tmp.XXX&quot; 为模板，其中的 &quot;X&quot; 数量必须大于等于 3），如 tmp.hKg</span></span><br><span class="line">mktemp tmp.XXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 test.txt 中查找 money 这个字符串，grep 查找是区分大小写的</span></span><br><span class="line">grep money test.txt</span><br><span class="line">ls -l | grep -Po <span class="string">&#x27;git-[a-z]+.exe&#x27;</span> <span class="comment"># 参数 “-o” 表示只显示匹配内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 file1 的文件内容加上行号后输入 file2 这个文件里</span></span><br><span class="line">cat -n file1 &gt; file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 file1 和 file2 的文件内容加上行号（空白行不加）之后将内容附加到 file3 里</span></span><br><span class="line">cat -b file1 file2 &gt;&gt; file3</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把 test.log 文件扔进垃圾箱，赋空值 test.log（清空文本 test.log 内容）</span></span><br><span class="line">cat /dev/null &gt; test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 xxx.csv 文件中的第二、第三列</span></span><br><span class="line">awk -F <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123; print $2, $3 &#125;&#x27;</span> xxx.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空文本 test.log 内容</span></span><br><span class="line"><span class="built_in">echo</span> &gt; test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时显示新追加到文件中的信息</span></span><br><span class="line"><span class="comment"># tail -f test.log # &quot;-f&quot; 表示根据文件描述符进行追踪，当文件改名或被删除，追踪停止</span></span><br><span class="line">tail -F test.log <span class="comment"># &quot;-F&quot; 表示根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以十六进制的方式读取文件 test.log</span></span><br><span class="line">od -t x1 test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以十六进制的方式读取文件 test.txt</span></span><br><span class="line">hexdump -C test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件 test.log 的系统属性信息</span></span><br><span class="line"><span class="built_in">stat</span> test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 utf-8 编码显示文件 test.txt 内容  </span></span><br><span class="line">iconv -t utf-8 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># list dynamic dependencies，列出程序的动态依赖库</span></span><br><span class="line">ldd /bin/bash</span><br><span class="line"><span class="comment"># 将 /bin/bash 以及其依赖打包压缩至文件 rootfs.tar.gz 中</span></span><br><span class="line">ldd /bin/bash | perl -p -e <span class="string">&#x27;s#^\s*(\S+ =&gt; )?(/\S+) \(0x[0-9a-z]+\)$#$2#g&#x27;</span> | grep -v <span class="string">&#x27;linux-vdso&#x27;</span> | sed <span class="string">&#x27;$a/bin/bash&#x27;</span> | xargs tar zcvf rootfs.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个 bash，参数 “--rcfile” 指定预加载的 .bashrc 文件</span></span><br><span class="line">bash --rcfile .bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件（&quot;-k&quot; 表示忽略 https 证书校验，&quot;-O&quot; 表示使用 URL 中默认的文件名保存文件到本地，&quot;-s&quot; 表示不显示下载进度，&quot;-L&quot; 表示自动跟踪 URL 重定向跳转，&quot;--retry 3 --retry-delay 2&quot; 表示失败重试 3 次，每次间隔 2 秒）</span></span><br><span class="line">curl -k -O -s -L https://github.com/btraceio/btrace/releases/download/v1.3.11.1/btrace-bin-1.3.11.1.zip --retry 3 --retry-delay 2 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="comment"># curl -k -s -L https://sourceforge.net/projects/jodconverter/files/JODConverter/2.2.2/jodconverter-2.2.2.zip/download -o jodconverter-2.2.2.zip --retry 3 --retry-delay 2 &gt; /dev/null 2&gt;&amp;1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取某个路径下的目录名</span></span><br><span class="line">dirname /home/test.txt <span class="comment"># /home</span></span><br><span class="line"><span class="comment"># 取某个路径下的文件名</span></span><br><span class="line">basename /home/test.txt <span class="comment"># test.txt</span></span><br><span class="line"><span class="comment"># 取某个路径下的文件名（并去除文件后缀 .txt）</span></span><br><span class="line">basename /home/test.txt .txt <span class="comment"># test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据文件名 “filename” 查找文件<br>  <code>find -name filename</code><br>  在当前目录下所有txt文件中查找内容 “word”<br>  <code>find -name &quot;*.txt&quot; | grep &quot;word&quot;</code><br>  <code>find . -name &quot;*.txt&quot; | grep &quot;word&quot;</code><br>  删除当前目录及子目录下所有 <em>.lastUpdated 文件<br>  <code>find -name &quot;*.lastUpdated&quot; | xargs rm</code><br>  强制删除当前目录及子目录下所有 *.git 目录及其子文件<br>  <code>find -name &quot;.git&quot; | xargs rm -rf</code><br>  删除 7 天前的文件（可用于定期手工清理 tomcat 日志文件）<br>  <code>find -mtime +7 -exec rm -f &#123;&#125; \;</code><br>  把 /home/logs/ 目录下所有 *.log 文件中的字符 “abc” 替换成 “def”<br>  <code>find /home/logs/ -name &quot;*.log&quot; | xargs sed -i &quot;s/abc/def/g&quot;</code><br>  统计当前目录及子目录下所有 *.java 文件的总行数<br>  <code>find -name &quot;*.java&quot; | xargs wc -l</code><br>  统计当前目录及子目录下所有文件的类型（后缀名）<br>  <code>find -name &quot;*.*&quot; | sed &#39;s/.*\./\./&#39; | sort | uniq</code><br>  查找当前目录下所有 *. java、</em>. xml、*. txt文件（参数 “-o” 表示或者）<br>  <code>find -name *. java -o -name *. xml -o -name *. txt</code><br>  查找当前目录下所有文件，并列出其详细信息<br>  <code>find ./ ! -type d -exec ls -l &#123;&#125; \;</code><br>  遍历查找当前目录下所有文件内容，查找包含内容 ‘“id”: ‘ 的行，使用正则替换，筛选出 id 的值并作为数进行排序，取最后一个值（即找出当前目录下所有文件中定义的 id 最大值）<br>  <code>grep -rn &#39;&quot;id&quot;: &#39; . | sed &#39;s/^.*&quot;id&quot;: \([0-9]\+\),/\1/&#39; | sort -n | tail -n 1</code><br>  <code>printf &quot;%d\n&quot; $(($(grep -rn &#39;&quot;id&quot;: &#39; . | sed &#39;s/^.*&quot;id&quot;: \([0-9]\+\),/\1/&#39; | sort -n | tail -n 1) + 1))</code><br>  <code>printf &quot;%04x\n&quot; $((16#$(grep -rn &#39;&quot;key&quot;: &#39; . | sed &#39;s/^.*&quot;key&quot;: &quot;\([a-zA-Z0-9]\+\)&quot;,/\1/g&#39; | sort -n | tail -n 1) + 1))</code><br>  批量重命名文件<br>  <code>find -name &#39;*.json&#39; | cut -c 3- | xargs -i mv &#123;&#125; A_&#123;&#125;</code><br>  查询当前目录下所有目录（不包含子目录），并删除目录名称中的 B_ 前缀<br>  <code>find . -maxdepth 1 -type d | tail -n +2 | sed &#39;s#^./B_##&#39; | xargs -I&#123;&#125; mv ./B_&#123;&#125; ./&#123;&#125;</code><br>  查询当前目录下所有 zip 文件，并将文件名中 “_” 去除  </p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find *.zip | while read n; do mv $n `echo &quot;$n&quot; | sed &#x27;s/_//g&#x27;`; done</span><br></pre></td></tr></table></figure>
<p>  查找当前目录下重复的多版本 jar 包<br>  <code>ls -a | sed &#39;s/-[^-]*\.jar$//g&#39; | sort | uniq -d</code></p>
</li>
<li><p>监听文件 catalina.out，直到文件中出现 “org.apache.catalina.startup.Catalina.start Server startup in [0-9]+ ms” 后退出</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># (tail -f -n0 catalina.out &amp;) | grep -m 1 -E &quot;org.apache.catalina.startup.Catalina(.start)|- Server startup in [0-9]+ ms&quot; &amp;&amp; pkill -s 0 tail</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># (tail -f -n0 catalina.out &amp;) | (grep -m 1 -E &quot;org.apache.catalina.startup.Catalina(.start)|- Server startup in [0-9]+ ms&quot; &amp;&amp; ( \</span></span><br><span class="line"><span class="comment"># 	ps | grep tail | grep -oP &#x27;^\s*([0-9]+)\s+&#x27; | sed &#x27;s/ //g&#x27; | xargs kill -15 \</span></span><br><span class="line"><span class="comment"># )) &gt; /dev/null</span></span><br><span class="line"></span><br><span class="line">   tail -F -n 0 catalina.out | grep -m 1 -P <span class="string">&quot;org.apache.catalina.startup.Catalina(.start)|- Server startup in [0-9]+ ms&quot;</span> &amp;&amp; (</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">&#x27;Tomcat has started.&#x27;</span></span><br><span class="line">       <span class="comment"># ...</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改文件读写权限（文件或目录的拥有者、文件或目录的所属群组、其他用户。读取权限 ‘r’ 代号为 “4”，写入权限 ‘w’ 代号为 “2”，执行或切换权限 ‘x’ 代号为 “1”，不具任何权限 ‘-‘ 代号为 “0”）<br>  <code>chmod 777 filename</code><br>  修改文件读写权限为 “-rwsr-xr-x”（给 /bin/cat 加上 setUID 权限，系统可以临时把这个文件的所有者（root）身份角色赋给普通用户）（<a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2013-08/88587.htm">特殊权限 “setuid” 代号为 “4”，”setgid” 代号为 “2”，”stick bit” 代号为 “1”</a>）<br>  <code>chmod 4755 /bin/cat</code><br>  修改目录 “folder” 以及其下所有文件、文件夹读写权限<br>  <code>chmod -R 777 folder</code><br>  文件增加执行权限<br>  <code>chmod +x filename</code><br>  当前用户增加执行权限，组用户增加写权限<br>  <code>chmod u+x g+w filename</code><br>  当前用户具有读、写、执行权限，组用户具有读写权限，其他用户具有读权限<br>  <code>chmod u=rwx g=rw o=r filename</code><br>  修改文件的属主为 root<br>  <code>chown root filename</code><br>  <code>chown -R root filename</code><br>  修改文件的属主为 sa，群组为 sagroup<br>  <code>chown sa:sagroup filename</code><br>  修改文件的群组为 sagroup<br>  <code>chgrp sagroup filename</code></p>
</li>
<li><p>保护文件，禁止修改删除移动<br>  <code>chattr +i hello.txt</code><br>  去保护<br>  <code>chattr -i hello.txt</code></p>
</li>
<li><p>创建文件或目录 a 的硬连接 b（新建的文件是原文件的一个别名，当原文件被删除，新建的文件仍然可用）<br>  <code>ln a b</code><br>  创建文件或目录 a 的软连接（又称符号连接，类似于快捷方式，新建的文件可以指向不存在的文件）<br>  <code>ln -s a b</code><br>  删除连接 b<br>  <code>rm -f b</code></p>
</li>
<li><p>拷贝本地目录 /home/sa 目录及子文件到远程主机 192.168.1.1 的 /home/sa<br>  <code>scp -r /home/sa root@192.168.1.1:/home/sa</code><br>  将远程主机 192.168.1.1 上的 /home/sa/info.log 复制到本机的 /tmp 下<br>  <code>scp root@192.168.1.1:/home/sa/info.log /tmp</code></p>
</li>
<li><p>同步远程主机 192.168.1.1 上目录 /home/sa/dic/ 下除 .* 和 log 之外的文件到本地目录 /home/sa/dic 下<br>  <code>rsync -a --delete --exclude=&quot;.*&quot; --exclude=&quot;log&quot; root@192.168.1.1:/home/sa/dic/ /home/sa/dic/</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/AloneSword/p/4918791.html">使用 GPG 对文件加密</a><br>  生成（自己的）密钥<br>  <code>gpg --gen-key</code><br>  导出（自己的）公钥，其中（自己的）用户 ID 为 “Ke Sun <a href="mailto:&#x6b;&#101;&#x2e;&#115;&#x75;&#110;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;">&#x6b;&#101;&#x2e;&#115;&#x75;&#110;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a>“<br>  <code>gpg --armor --output public-key.txt --export &quot;Ke Sun &lt;ke.sun@gmail.com&gt;&quot;</code><br>  导入（他人的）公钥<br>  <code>gpg --import public-key.txt</code><br>  生成文件 “hello.txt” 的签名 “hello.txt.asc”<br>  <code>gpg --armor --detach-sign hello.txt</code><br>  校验文件 “hello.txt” 的签名 “hello.txt.asc”<br>  <code>gpg --verify hello.txt.asc hello.txt</code></p>
</li>
<li><p>计算文件的 sha-1 校验和<br>  <code>sha1sum a.txt</code><br>  计算文件的 md5 校验和<br>  <code>md5sum a.txt</code><br>  计算文件的 md5 校验和，并保存至文件 hello.txt.md5 中<br>  <del><code>md5sum &lt; hello.txt &gt; hello.txt.md5</code></del><br>  <code>md5sum hello.txt &gt; hello.txt.md5</code><br>  根据 hello.txt.md5 校验相应的文件<br>  <code>md5sum -c hello.txt.md5</code><br>  计算字符串 “hello, world” 的 md5 校验和<br>  <code>echo -n &quot;hello, world&quot; | md5sum</code></p>
</li>
<li><p>查找命令文件所在位置<br>  <code>which sha1sum</code></p>
</li>
<li><p>显示 /etc/hosts 的路径<br>  <code>ls /etc/hosts</code><br>  列出目录 /etc 下所有文件<br>  <code>ls -l /etc</code><br>  <code>ls -a /etc</code><br>  列出当前目录下所有文件和目录，并着色（参数 “–color” 表示对结果进行着色）<br>  <code>ls --color</code></p>
</li>
<li><p>使用 unix2dos 将文件 test.txt 由 unix 格式转换为 windows 格式（即将 “\n” 替换为 “\n\r”）<br>  <code>unix2dos test.txt</code><br>  <code>/bin/find -name &#39;*.txt&#39; | xargs unix2dos</code><br>  使用 dos2unix 将文件 test.txt 由 windows 格式转换为 unix 格式（即将 “\n\r” 替换为 “\n”）<br>  <code>dos2unix test.txt</code></p>
</li>
<li><p>使用 diff 简单比较两个文件 a.txt、b.txt<br>  <code>diff a.txt b.txt</code><br>  使用 diff 比较两个目录 a、b<br>  <code>diff -ywrNa ./a ./b</code><br>  使用 diff 比较两个目录 folder1、folder2 下所有文件，但不包括 “.git”、”bin” 目录和 “.classpath” 文件<br>  <del><code>diff -ywrNa folder1/ folder2/ -x .git -x bin -X .classpath</code></del><br>  <code>diff -ywrNa folder1/ folder2/ -x .git -x bin -x .classpath</code><br>  使用diff比较两个文件 a.txt、b.txt 并计数不相同的行数<br>  <code>diff -yw a.txt b.txt | grep -E &#39;&lt;|&gt;|\|&#39; | wc -l</code><br>  比较两个文件 f1、f2，并导出补丁脚本（不包括相同的行）<br>  <code>diff -Nu f1 f2 | grep -E &#39;^[^ ]&#39;</code><br>  比较两个目录 d1、d2，并导出补丁脚本（不包括相同的行）<br>  <code>diff -Nur ./d1 ./d2 | grep -E &#39;^[^ ]&#39;</code>  </p>
</li>
<li><p>比较两个文件 f1、f2，并导出补丁脚本 f2.patch（windows 下可使用 TortoiseUDiff 或 TortoiseGitUDiff 打开 .patch/.diff 文件）<br>  <code>diff -Nu f1 f2 &gt; f2.patch</code><br>  给文件 f1 打补丁 f2.patch，结果 f1 应与 f2 一致<br>  <del><code>patch -p0 &lt; f2.patch</code></del><br>  <code>patch f1 &lt; f2.patch</code><br>  给文件 f1 撤销补丁 f2.patch，文件 f1 被还原<br>  <del><code>patch -RE -p0 &lt; f2.patch</code></del><br>  <code>patch -R f1 &lt; f2.patch</code></p>
</li>
<li><p>比较两个目录、导出补丁脚本、打补丁、撤销补丁</p>
<ol>
<li>比较两个目录 d1、d2，并导出补丁脚本 d2.patch<br> <code>diff -Nur ./d1 ./d2 &gt; d2.patch</code></li>
<li>给目录 d1 打补丁 d2.patch，结果 d1 应与 d2 一致<ul>
<li>方法一：<br>  <code>patch --binary --dir ./d1 &lt; d2.patch</code></li>
<li>方法二：<br>  <code>cd ./d1 &amp;&amp; patch --binary -p1 &lt; d2.patch &amp;&amp; cd ../</code></li>
</ul>
</li>
<li>给目录 d1 撤销补丁 d2.patch，目录 d1 被还原<ul>
<li>方法一：<br>  <code>patch --binary -R --dir ./d1 &lt; d2.patch</code></li>
<li>方法二：<br>  <code>cd ./d1 &amp;&amp; patch --binary -R -p1 &lt; d2.patch &amp;&amp; cd ../</code></li>
</ul>
</li>
</ol>
</li>
<li><p>将 docx 文件转换为 txt 文件<br>  <code>docx2txt *.docx</code></p>
</li>
<li><p>交集、并集、差集</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交集</span></span><br><span class="line"><span class="comment">#grep -F -f a.txt b.txt</span></span><br><span class="line"><span class="comment">#cat b.txt | grep -F -f a.txt</span></span><br><span class="line">sort a.txt b.txt | uniq -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line"><span class="comment">#cat a.txt b.txt | sort | uniq</span></span><br><span class="line">sort a.txt b.txt | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集（a.txt - b.txt）</span></span><br><span class="line"><span class="comment">#grep -F -v -f b.txt a.txt</span></span><br><span class="line"><span class="comment">#cat a.txt | grep -F -v -f b.txt</span></span><br><span class="line">sort a.txt b.txt b.txt | uniq -u</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul>
<li><p>返回到上一次的工作目录<br>  <code>cd -</code><br>  返回上一层目录<br>  <code>cd ../</code><br>  返回到用户的家目录<br>  <code>cd ~</code><br>  进入到文件 /etc/sudoers 所在目录<br>  <code>cd $(dirname /etc/sudoers)</code></p>
</li>
<li><p>统计 / 目录下目录或文件所占用磁盘大小，”-d 1” 表示遍历的目录深度为 1<br>  <code>du -h -d 1 /</code></p>
</li>
</ul>
<h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b5ec0df362e5">vim 编辑器</a></p>
<ul>
<li>使用 vi 编辑器编辑文本文件 temp.txt<br>  <code>vi temp.txt</code>  </li>
<li>以二进制模式（binary mode）编辑文件 temp.txt（该模式下，\r 会显示为 ^M，即不可打印字符（non-printable char））<br>  <code>vi -b temp.txt</code></li>
<li>同时打开多个文件<br>  <code>vi file1 file2 file3 ...</code><blockquote>
<ul>
<li>Edit 模式（刚启动时 vim 工作于 edit 模式, 主要是用来进行一下文本操作）</li>
<li>Insert 模式（键入 “i” 进入该模式，按下 <Esc> 退出该模式）</li>
<li>Command 模式（使用 “:”，按下 <Esc> 键退出 Insert 模式回到 Normal 模式）<ul>
<li>输入 <code>:%!xxd</code> 可将当前文件转换为 16 进制文本，再次输入 <code>:%!xxd -r</code> 可将 16 进制文本转换会原文本</li>
<li>先键入 <code>gg</code>，再键入 <code>=</code>，再键入 <code>G</code>，可使全部代码自动对齐</li>
<li>输入 <code>:X</code> 可设置当前文本加密，按照提示输入密码后保存退出完成加密（若输入密码为空，则表示不加密，即解密）<blockquote>
<p>若提示 “E21: Cannot make changes, ‘modifiable’ is off” 错误信息，需输入 <code>:set modifiable</code> 将文件设置为可修改模式，之后再重复上一步骤中的命令</p>
</blockquote>
</li>
<li>输入 <code>:s/old/new</code>，表示替换当前行中第一个 old 为 new<br>  输入 <code>:%s/old/new/g</code>，表示替换全文中所有 old 为 new  </li>
<li>输入 <code>/keyword</code>，表示向下搜索 keyword 关键词（按 <N> 表示查找下一个）</li>
<li>输入 <code>?keyword</code>，表示向上搜索 keyword 关键词（按 <N> 表示查找上一个）</li>
<li>输入 <code>:set number</code> 显示行号</li>
<li>输入 <code>:set hlsearch</code> 开启搜索结果高亮</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>在当前目录下递归查找内容 “word”<br>  <code>grep -rn word ./</code><br>  在文件 “temp.txt” 中使用正则表达式 “([0-9]+)(.[0-9]+){3}” 查找 IP 地址（参数 “-E” 表示使用正则表达式，参数 “-o” 表示只显示一行中匹配的部分，<font color=red>grep 无法匹配 CRLF 换行符，即无法跨行匹配</font>）<br>  <code>grep -E &#39;([0-9]+)(\.[0-9]+)&#123;3&#125;&#39; temp.txt</code><br>  <del><code>grep -oE &#39;([0-9]+)(\.[0-9]+)&#123;3&#125;&#39; *.txt</code></del><br>  在文件 *.txt 中查找字符串 “hello”，并显示其所在行以及上下 5 行（参数 “-C” 表示匹配字符串所在行以及上下几行，参数 “-B” 表示显示字符串所在行及前几行，参数 “-A” 表示显示字符串所在行及后几行）<br>  <code>grep -C 5 &#39;hello&#39; *.txt</code><br>  查找 catalina.sh 文件中 webresource 所在行号<br>  <code>grep -n webresource catalina.sh | cut -d : -f1</code><br>  查找 catalina.sh 文件中 webresource 所在行，并打印下一行行号<br>  <code>echo $(($(grep -n webresource catalina.sh | cut -d : -f1) + 1))</code><br>  使用正则表达式 [a-zA-Z0-9_]+ 查找所有的匹配项（tail -n +7 表示忽略结果中的前7行）<br>  <code>curl http://127.0.0.1:8080/admin/collections?action=List | grep -o -E &#39;[a-zA-Z0-9_]+&#39; | tail -n +7</code><br>  参数 “-P” 表示使用 perl 正则表达式查询<br>  <code>grep -P &#39;^PermitRootLogin ((?!no)\S)+$&#39; /etc/ssh/sshd_config</code><br>  参数 “–color=auto” 表示高亮显示结果<br>  <code>grep --color=auto &#39;hello, world&#39; hello.txt</code><br>  参数 “–exclude” 表示排除文件<br>  <code>grep -l -r --include &#39;*.csv&#39; --exclude &#39;res.csv&#39; --exclude &#39;list.txt&#39; &#39;hello, world&#39; . | wc -l</code></p>
</li>
<li><p>就地替换文件 debug.log 中所有 “world” 为 “luffy”（参数 “-i” 表示直接修改文件内容）<br>  <code>sed -i &#39;s/world/luffy/g&#39; debug.log</code><br>  将文件 debug.log 中所有 “world” 替换为 “luffy” 并保存至 “debug.new.log” 中<br>  <code>sed &#39;s/world/luffy/g&#39; debug.log &gt; debug.new.log</code><br>  在文件 “temp.txt” 中使用正则表达式 “([0-9]+)(.[0-9]+){3}” 查找 IP 地址（参数 “-r” 表示使用正则表达式，参数 “-n” 和标志 “p” 表示只打印匹配的行）<br>  <code>sed -nr &#39;/([0-9]+)(\.[0-9]+)&#123;3&#125;/p&#39; temp.txt</code><br>  在文件 “temp.txt” 末尾添加一行 “hello, world”<br>  <code>sed &#39;$ahello, world&#39; hello.txt</code><br>  将所有的行（以 “|” 为分隔符，拼接为一行）<br>  <code>sed &#39;:a;N;$!ba;s/\n/|/g&#39; xxx.txt</code><br>  查找 catalina.sh 文件中 webresource 所在行，并在下一行添加一行 “echo hello, world”<br>  <code>sed &quot;$(($(grep -n webresource catalina.sh | cut -d : -f1) + 1))&quot;&#39;iecho hello, world&#39; catalina.sh</code><br>  或</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/webresource/ &#123;</span></span><br><span class="line"><span class="string">  n</span></span><br><span class="line"><span class="string">  i echo hello, world</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> catalina.sh</span><br><span class="line"><span class="comment"># 其中 /webresource/ 表示匹配 webresource 所在行，n 表示下一行，i 表示插入行， r 表示插入文件内容（如 r hello.txt）</span></span><br></pre></td></tr></table></figure>
<p>  筛选第二行内容<br>  <code>echo -e &quot;1\n2\n3&quot;  | sed -n 2p</code></p>
<blockquote>
<p>其中</p>
<ul>
<li>参数，如 sed -i ‘/…/…/‘ …<ul>
<li><code>i</code> 表示将修改替换的内容写入到原文件中</li>
</ul>
</li>
<li>查找标志，如 sed ‘s/…/…/‘ …<ul>
<li><code>s</code> 表示替换内容</li>
<li><code>n</code> 表示新增空行</li>
<li><code>i</code> 表示插入一行，如在第四行插入内容 sed ‘4ihello, world’ …</li>
</ul>
</li>
<li>替换标志，如 sed ‘/…/…/g’ …<ul>
<li><code>g</code> 表示全局替换</li>
<li><code>i</code> 表示不区分大小写</li>
</ul>
</li>
</ul>
</blockquote>
<p>  替换配置文件中第一次出现的文本内容<br>  <code>sed -i &#39;0,/IP = .*/s/IP = .*/IP = 10.10.10.10/&#39; /usr/share/config.conf</code></p>
</li>
<li><p>awk</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk 忽略引号中的分隔符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;a,b,c,&quot;d,e&quot;,f&#x27;</span> | awk -v -FPAT <span class="string">&#x27;([^,]*)|(&quot;[^&quot;]*&quot;)&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> <span class="comment"># &quot;d,e&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># awk 删除行</span></span><br><span class="line">awk -v -FPAT <span class="string">&#x27;([^,]*)|(&quot;[^&quot;]|&quot;&quot;*&quot;)&#x27;</span> <span class="string">&#x27;&#123; for (i = 1; i &lt;= NF; i++) &#123; if (i != 2) &#123; printf(&quot;%s&quot;, $i); if (i != NF) printf(&quot;,&quot;); &#125; &#125; printf(&quot;\n&quot;) &#125;&#x27;</span> test.csv 1&lt;&gt; test.csv</span><br><span class="line"></span><br><span class="line">git diff | grep -P <span class="string">&#x27;^(?!---)-&#x27;</span> | sed <span class="string">&#x27;s/^-//g&#x27;</span> | awk -v -FPAT <span class="string">&#x27;([^,]*)|(&quot;[^&quot;]|&quot;&quot;*&quot;)&#x27;</span> <span class="string">&#x27;function contain(diamond, rough, x, y) &#123; for (x in rough) y[rough[x]]; return diamond in y; &#125; BEGIN &#123; split(&quot;20&quot;, indexs, &quot;,&quot;) &#125; &#123; for (i = 1; i &lt;= NF; i++) &#123; if (!contain(i, indexs)) &#123; printf(&quot;%s&quot;, $i); if (i != NF) printf(&quot;,&quot;); &#125; &#125; printf(&quot;\n&quot;) &#125;&#x27;</span> &gt; temp.okf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据文件属主，分组显示文件</span></span><br><span class="line">ls -l | tail -n +2 | awk <span class="string">&#x27;&#123; ds[$3] += 1; fs[$3, ds[$3]] = $9; &#125; END &#123; for (x in ds) &#123; print x; for (y = 1; y &lt; ds[x]; y++) &#123; printf(&quot;  %s\n&quot;, fs[x, y]); &#125; &#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1348124/replace-an-xml-elements-value-sed-regular-expression">使用正则表达式替换文本内容（不保存修改到文件）</a><br>  <code>perl -p -0777 -e &#39;s/&lt;Context docBase=&quot;solr&quot;[^&gt;]*&gt;//&#39; server.xml</code><br>  使用正则表达式替换文本内容<br>  <code>perl -p -0777 -i -e &#39;s/&lt;Context docBase=&quot;solr&quot;[^&gt;]*&gt;//&#39; server.xml</code><br>  参数 -0777 会忽略分割符，无法匹配行首和行尾<br>  <code>perl -p -i -e &#39;s/^hello$/world/&#39; hello.txt</code></p>
</li>
<li><p>使用 cut 截断字符串（截取 当前登录信息中 “(“ 和 “)” 之间的内容，即登录者的 ip）<br>  <code>who am i | cut -d &#39;(&#39; -f2 | cut -d &#39;)&#39; -f1</code></p>
</li>
<li><p>向文件 temp.txt 中写入一行或多行内容，输入结束后，另起一行输入 “EOF” 表示结束写操作</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat &lt;&lt; EOF # 使用 EOF，需要对特殊字符如 &quot;$&quot;、&quot;`&quot;进行转义 &quot;\$&quot;、&quot;\`&quot;</span></span><br><span class="line"><span class="comment"># cat &lt;&lt; &quot;EOF&quot; # 加引号如 &quot;EOF&quot; 则特殊字符无需转义</span></span><br><span class="line">cat &gt;&gt; temp.txt &lt;&lt; <span class="string">&quot;EOF&quot;</span></span><br><span class="line">hello, world</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>大文件分割，如将文件 catalina.out 分割为多个以 catalina_ 为前缀的文件（单个文件不超过 10 MB），如 catalina_aa、catalina_ab、catalina_ac…<br>  <code>split -C 10M catalina.out catalina_</code></p>
</li>
<li><p>使用 jq 解析 json</p>
<ol>
<li>安装<br> <code>apt install jq</code></li>
</ol>
<ul>
<li>格式化显示 package.json 文件中的 json 报文<br>  <code>jq . package.json</code></li>
<li>格式化显示 /author/name 属性<br>  <code>jq .author.name package.json</code></li>
<li>格式化显示 /contributors 属性<br>  <code>jq -r .contributors[] package.json</code></li>
<li>格式化显示 /contributors 数组的第一个元素的 name 属性<br>  <code>jq .contributors[0].name package.json</code></li>
<li>压缩 json 报文，并写入到文件 package.min.json 中<br>  <code>jq --compact-output . package.json&gt; package.min.json</code></li>
<li>筛选出 /users 数组元素中 id、name 属性<br>  <code>cat users.json | jq &#39;.users[] | &#123; id, name &#125;&#39;</code><br>  筛选出 name 为 zhangsan 的 user<br>  <code>jq -r &#39;.users[] | select(.name == &quot;zhangsan&quot;)&#39; users.json</code><br>  筛选出 name 为 zhangsan 或 lisi 的 user<br>  <code>jq -r &#39;.users[] | select(.name == &quot;zhangsan&quot;, .name == &quot;lisi&quot;)&#39; users.json</code><br>  筛选出 age 大于 18，并且 name 为 zhangsan 的 user，并过滤（只展示）name 属性<br>  <code>jq -r &#39;.users[] | select(.age &gt; 18) | select(.name == &quot;zhangsan&quot;) | .name&#39; users.json</code></li>
<li>筛选出 /users 数组元素中 id、name 属性，将结果中每两行拼接为一行（最终每行以 “[id]  [name]” 显示 users）<br>  <code>jq -r &#39;.users[] | &#123; id, name &#125;[]&#39; users.json | sed &#39;N;s/\n/\t/g&#39;</code></li>
<li>循环遍历 /users 数组元素中 id、name 属性，以 “id: $id, name: $name” 格式显示<br>  <code>jq -r &#39;.[] | .id + &quot; &quot; + .name &#39; users.json | while read -r id name; do echo &quot;id: $id, name: $name&quot;; done</code></li>
</ul>
</li>
<li><p>使用 xmllint 解析 xml</p>
<ul>
<li>格式化显示 xml 文档<br>  <code>echo -n &quot;$xml_content&quot; | xmllint --format -</code></li>
<li>获取文件 users.xml 中 <code>//user</code> 节点下的内容<br>  <code>xmllint --xpath &#39;//user/text()&#39; users.xml</code></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41114695/get-pom-xml-version-with-xmllint">获取 pom.xml 文件中的 groupId、artifactId、version</a><br>  <code>xmllint --xpath &#39;concat(/*[local-name()=&quot;project&quot;]/*[local-name()=&quot;groupId&quot;]/text(),&quot;  &quot;,/*[local-name()=&quot;project&quot;]/*[local-name()=&quot;artifactId&quot;]/text(),&quot;  &quot;,/*[local-name()=&quot;project&quot;]/*[local-name()=&quot;version&quot;]/text())&#39; pom.xml</code></li>
</ul>
</li>
</ul>
<h2 id="备份压缩"><a href="#备份压缩" class="headerlink" title="备份压缩"></a>备份压缩</h2><ul>
<li><p>压缩打包目录 “content” 至文件 “file.tar.gz”<br>  <code>tar -zcvf file.tar.gz ./content</code><br>  查阅压缩包文件 “file.tar.gz”<br>  <code>tar -ztvf file.tar.gz</code><br>  解压缩文件 “file.tar.gz”<br>  <code>tar -zxvf file.tar.gz</code><br>  <code>tar -jxvf ffmpeg-3.2.2.tar.bz2</code><br>  解压指定文件或目录<br>  <code>tar zxvf tomcat.tar.gz tomcat/conf/server.xml</code><br>  查找所有包含名称 “*.usl” 的文件并打包压缩 “usl.tar.gz” 到当前目录（保持目录结构）<br>  <code>find . -name &quot;*.usl&quot; | xargs tar zcvf usl.tar.gz</code><br>  查找当前目录及子目录下所有包含名称 *.java、 *.xml、 *.jsp 的文件，并将其打包到 p.tar 中<br>  <code>find -name &quot;*.java&quot; -o -name &#39;*.xml&#39; -o -name *.jsp | xargs tar rvf p.tar</code></p>
</li>
<li><p>使用 bzip2 压缩 messages 文本文件（/var/log/messages，即系统日志文件）为 messages.bz2<br>  <code>bzip2 messages</code><br>  使用 bzip2 解压缩 messages.bz2 文件为 messages<br>  <code>bzip2 -d messages.bz2</code></p>
</li>
<li><p>使用 gzip 解压缩 train-labels-idx1-ubyte.gz<br>  <code>gzip -d train-labels-idx1-ubyte.gz</code></p>
</li>
<li><p>将文件 “hello.txt” 添加至压缩包 “hello.zip” 中<br>  <code>zip hello.zip hello.txt</code><br>  解压缩 “hello.zip” 至当前目录下<br>  <code>unzip hello.zip</code><br>  解压缩 “arc.zip” 中的 src\hello.java 至 \tmp 目录下<br>  <code>unzip -j &quot;arc.zip&quot; src\hello.java -d \tmp</code><br>  查看 “hello.zip” 中的文件<br>  <code>unzip -v hello.zip</code><br>  将文件 “file1”、”file2” 添加至压缩包 “result.zip” 中<br>  <code>zip result.zip file1 file2</code><br>  将 “tomcat-native-1.1.34-win32-bin.zip” 中的 bin/x64 目录下的 tcnative-1.dll 解压到 $CATALINA_HOME/bin 目录下<br>  <code>unzip -j -q tomcat-native-1.1.34-win32-bin.zip &#39;bin/x64/tcnative-1.dll&#39; -d $CATALINA_HOME/bin</code></p>
</li>
<li><p>将文件（或目录） “hello.txt” 压缩至压缩包 “hello.7z” 中<br>  <code>7z a hello.7z hello.txt</code><br>  解压缩 “hello.7z” 至当前目录下<br>  <code>7z x hello.7z</code><br>  解压缩 “hello.rar” 至当前目录下<br>  <code>7z x hello.rar</code></p>
</li>
</ul>
<h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><ul>
<li><p>查看服务<br>  <code>chkconfig</code><br>  查看所有服务（ubuntu，the status is [ + ] for running services, [ - ] for stopped services and [ ? ] for services without a ‘status’ command.）<br>  <code>service --status-all</code></p>
</li>
<li><p>显示环境变量 HOME<br>  <code>echo $HOME</code><br>  设置临时环境变量(只对当前进程有效，不会传递给子进程)<br>  <code>path=jdk/bin:$&#123;PATH&#125;</code><br>  设置环境变量（变量在关闭 shell 时失效，不仅对当前进程有效，而且会传递给子进程）（export 用于 bash，setenv 用于 csh）<br>  <code>export name=value</code><br>  <code>setenv name value</code><br>  显示当前用户的变量<br>  <code>env</code><br>  显示当前 shell 的变量，包括当前用户的变量<br>  <code>set</code><br>  <code>export</code><br>  删除环境变量<br>  <code>unset name</code></p>
</li>
<li><p>添加全局的环境变量<br>  <code>echo &#39;export PATH=&quot;$PATH:/opt/jdk/bin&quot;&#39; &gt;&gt; ~/.cshrc</code><br>  添加当前用户环境变量（需要注销后才能生效）<br>  <code>echo &#39;export PATH=&quot;$PATH:/opt/jdk/bin&quot;&#39; &gt;&gt; /etc/profile</code></p>
</li>
<li><p>安装 deb 软件包 “app.deb”（Debian、Ubuntu 等 Linux 发行版的软件安装包）<br>  <code>sudo dpkg -i app.deb</code><br>  删除软件包 “app”（删除配置信息）<br>  <code>sudo dpkg -P app</code><br>  删除软件包 “app”（保留配置信息）<br>  <code>sudo dpkg -r app</code><br>  显示所有已经安装的 deb 包，同时显示版本号以及简短说明<br>  <code>dpkg -l</code></p>
</li>
<li><p>安装 rpm 软件包 “app.rpm”（Red Hat、Fedora、CentOS、SuSE 等 Linux 发行版的软件安装包）<br>  <code>sudo rpm -i app.rpm</code><br>  删除软件包 “app”（删除配置信息）<br>  <code>sudo rpm -e app</code><br>  显示所有已经安装的 deb 包，同时显示版本号以及简短说明<br>  <code>rpm -qa</code></p>
</li>
<li><p>定时任务  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询定时任务</span></span><br><span class="line">crontab -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询定时任务，不现实注释，并将结果导出到文件 crontab.data</span></span><br><span class="line">crontab -l | grep -v <span class="string">&#x27;^#&#x27;</span> &gt; crontab.data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加定时任务，每小时的第一分钟会发送广播 &quot;hello, world&quot;</span></span><br><span class="line"><span class="comment"># 格式为：minute hour day month dayofweek command</span></span><br><span class="line"><span class="comment"># minute: 每个小时的第几分钟执行该任务，hour: 每天的第几个小时执行该任务，day: 每月的第几天执行该任务， month: 每年的第几个月执行该任务，dayofweek: 每周的第几天执行该任务</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1 * * * * echo \&quot;hello, world\&quot; | wall&quot;</span> &gt;&gt; crontab.data</span><br><span class="line">crontab crontab.data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除当前用户下的所有定时任务  </span></span><br><span class="line">crontab -r</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看命令别名<br>  <code>alias</code><br>  设置别名<br>  <code>alias ll=ls -l</code></p>
</li>
</ul>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ul>
<li><p>以 root 用户权限执行命令 “touch file1”<br>  <code>sudo touch file1</code><br>  切换当前用户至 root 用户<br>  <code>su</code></p>
</li>
<li><p>关机重启  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">sudo reboot</span><br><span class="line">sudo shutdown -r now</span><br><span class="line">sudo shutdown -r 10 <span class="comment"># 过 10 分钟自动重启</span></span><br><span class="line">sudo shutdown -r 20:00 <span class="comment"># 在时间为 20:00 时候重启</span></span><br><span class="line"><span class="comment"># 关机</span></span><br><span class="line">sudo halt</span><br><span class="line">sudo poweroff</span><br><span class="line">sudo shutdown -h now</span><br><span class="line">sudo shutdown -h 10 <span class="comment"># 10 分钟后自动关机</span></span><br><span class="line">sudo shutdown -h 20:00 <span class="comment"># 在时间为 20:00 时候关机</span></span><br><span class="line"><span class="comment"># 注销</span></span><br><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前所有登录的终端用户信息、ip<br>  <code>who</code><br>  查询当前登录的用户信息<br>  <code>who am i</code><br>  <code>whoami</code><br>  显示目前登入系统的用户信息<br>  <code>w</code></p>
</li>
<li><p>查看历史命令执行记录<br>  <code>history</code>  </p>
<blockquote>
<ul>
<li>设置历史命令执行记录的格式为 “[日期 时间][ip地址][用户名]命令”<br><code>export HISTTIMEFORMAT=&quot;[%F %T][</code>who -u am i 2&gt;/dev/null| awk ‘{print $NF}’|sed -e ‘s/[()]//g’<code>][</code>whoami<code>]&quot;</code></li>
</ul>
</blockquote>
</li>
<li><p>用户管理</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了一个用户 luffy，其中 -d 和 -m 选项用来为登录名 luffy 产生一个主目录 /home/luffy</span></span><br><span class="line">useradd -d /home/luffy -m luffy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户的密码</span></span><br><span class="line">passwd luffy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户 luffy 在系统文件（主要是 /etc/passwd，/etc/shadow，/etc/group 等）中的记录，同时 &#x27;-r&#x27; 删除用户的主目录 /home/luffy</span></span><br><span class="line">userdel -r luffy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令将用户 luffy 的登录 Shell 修改为 bash，主目录改为 /home/luffy，用户组改为 developer</span></span><br><span class="line">usermod -s /bin/bash -d /home/luffy -g developer luffy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户 luffy 密码有效期</span></span><br><span class="line">chage -l luffy</span><br><span class="line"><span class="comment"># 设置用户有效期无限</span></span><br><span class="line">chage -M 99999 luffy</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋予用户 root 权限</p>
<ul>
<li>方法 1<br>  修改 /etc/sudoers 文件，添加用户 sa 信息<br>  <code>sa    ALL=(ALL)    ALL</code><br>  保存退出，则可以用 sa 帐号登录，然后用命令 su - ，即可获得 root 权限</li>
<li>方法 2<br>  修改 /etc/sudoers 文件，添加用户组 admin 信息<br>  <code>%admin  ALL=(ALL)   ALL</code><br>  保存退出<br>  修改用户 sa，使其属于 admin 组<br>  <code>usermod -g admin sa</code><br>  则可以用 sa 帐号登录，然后用命令 <code>su</code> 或 <code>su -</code> 或 <code>su - root</code>，即可获得 root 权限</li>
<li>方法 3<br>  修改 /etc/passwd 文件，找到用户 sa 所在行，把用户 ID 修改为 0<br>  如将<br>  <code>sa:x:500:500:sa:/home/sa:/bin/bash</code><br>  修改为<br>  <code>sa:x:0:500:sa:/home/sa:/bin/bash</code><br>  保存退出，则可以用 sa 帐号登录，即可获得 root 权限</li>
</ul>
</li>
<li><p>查看磁盘空间占用情况<br>  <code>df</code><br>  <a target="_blank" rel="noopener" href="http://www.cnblogs.com/yinzhengjie/p/6489374.html">查看内存占用情况</a>（默认单位为 KB，即等价于 <code>free -k</code>）<br>  <code>free</code></p>
<blockquote>
<p>以 MB 为单位显示内存使用情况<br><code>free -m</code><br>不显示包含 “-/+ buffers/cache” 的这一列，即不显示缓冲区调节列<br><code>free -t -o -m -s 1</code></p>
</blockquote>
<p>  实时显示系统中各个进程的资源占用状况<br>  <code>top</code><br>  查看网络设备（网卡、ip、子网掩码等）信息<br>  <code>ifconfig</code><br>  查看路由表（默认网关等）信息<br>  <code>route</code><br>  显示系统中所有 PCI 总线设备或连接到该总线上的所有设备<br>  （Host bridge 主板芯片，VGA compatible controller 显卡，Audio device 音频设备，PCI bridge 接口插槽，USB Controller USB 控制器，Ethernet controller 网卡）<br>  <code>lspci</code><br>  查看当前时间<br>  <code>date</code><br>  格式化输出当前时间，如20180331205217（可用于生成时间戳）<br>  <code>date +%Y%m%d%H%M%S</code>  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://blog.csdn.net/myweishanli/article/details/26172887</span></span><br><span class="line"></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> <span class="comment"># 2018-06-20 13:17:23</span></span><br><span class="line"></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;next monday&#x27;</span> <span class="comment"># 下周一的日期</span></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;next-day&#x27;</span> <span class="comment"># 明天的日期</span></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;tomorrow&#x27;</span> <span class="comment"># 明天的日期</span></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;last-day&#x27;</span> <span class="comment"># 昨天的日期</span></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;yesterday&#x27;</span> <span class="comment"># 昨天的日期</span></span><br><span class="line"></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;30 days ago&#x27;</span> <span class="comment"># 30天前的日期</span></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;-100 days&#x27;</span> <span class="comment"># 100天以前的日期</span></span><br><span class="line">date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span> -d <span class="string">&#x27;3 months&#x27;</span> <span class="comment"># 3个月后的日期</span></span><br></pre></td></tr></table></figure>
<p>  显示系统名、节点名称、操作系统的发行版号、操作系统版本、运行系统的机器 ID 号<br>  <code>uname -a</code><br>  显示当前的各种用户进程限制<br>  <code>ulimit -a</code><br>  每两秒显示一次系统资源信息（CPU、内存占用）<br>  <code>vmstat 2</code><br>  每两秒显示一次系统资源信息（CPU、内存占用），一共显示 100 次<br>  <code>vmstat 2 100</code>  </p>
</li>
<li><p>查看 $PID 进程占用的文件句柄数<br>  <code>ls -l /proc/$pid/fd | wc -l</code><br>  <del><code>ls /proc/$pid/fd | sed -n &quot;$=&quot;</code></del><br>  <del><code>lsof -n | awk &#39;&#123; print $2 &#125;&#39; | sort | uniq -c | sort -nr | more | grep $PID</code></del><br>  <del><code>lsof -p $pid | wc -l</code></del></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/407c2baef92e">lsof 的错误使用场景和查看打开文件数的正确方法</a></p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaofeiIDO/p/6170199.html">线程和 wait、sleep 命令</a></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sleep 10 <span class="comment"># 等待 10 秒，再继续下一操作</span></span><br><span class="line"></span><br><span class="line">sleep 10 &amp; <span class="comment"># 当前 shell 不等待，后台子 shell 等待</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wait 是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。</span></span><br><span class="line"><span class="built_in">wait</span> <span class="comment"># 等待 wait 所在 bash 上的所有子进程的执行结束，如上一句的 `sleep 10 &amp;`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进程、端口查询</p>
<ul>
<li>查询当前系统所有进程信息<br>  <code>ps -ef</code></li>
<li>杀死进程  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> （推荐使用）杀死 4044 进程，<span class="string">&quot;-15&quot;</span> 表示 SIGTERM 信号编码</span></span><br><span class="line">kill -15 4044</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （不推荐使用）强制杀死 4044 进程，<span class="string">&quot;-9&quot;</span> 表示 SIGKILL 信号编码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span> -9 4044</span></span><br></pre></td></tr></table></figure></li>
<li>已知端口号 8080，查询占用该端口号的进程信息（进程号）<br>  <code>netstat -anp | grep &quot;:8080&quot;</code><br>  <code>lsof -i :8080</code><br>  <code>lsof -i tcp | grep &quot;:8080&quot;</code><blockquote>
<p>netstat 中查看 tcp 状态</p>
<ul>
<li><code>LISTENING</code>: 端口处于处于侦听状态</li>
<li><code>ESTABLISHED</code>：已建立连接，即两台机器正在通信</li>
<li><code>CLOSE_WAIT</code>：对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成 CLOSE_WAIT 此时我方需要调用 close() 来使得连接正确关闭</li>
<li><code>TIME_WAIT</code>：我方主动调用 close() 断开连接，收到对方确认后状态变为 TIME_WAIT</li>
<li><code>SYN_SENT</code>：表示请求连接（当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为 SYN_SENT），如果连接成功了就变为 ESTABLISHED</li>
</ul>
</blockquote>
</li>
<li>已知进程号 4044，查询该进程的具体信息<br>  <code>ps 4044</code><br>  查看该进程启动的完整命令行<br>  <code>ps eho command -p 4044</code><br>  查看该进程启动时候所在的目录<br>  <code>readlink /proc/4044/cwd</code><br>  查看该进程启动时的完整环境变量<br>  <code>strings -f /proc/4044/environ | cut -f2 -d &#39; &#39;</code></li>
<li>已知进程号 4044，查询该进程所打开的网络连接<br>  <code>netstat -pan | grep 4044</code></li>
<li>查询所有 tomcat 进程并强制杀掉进程<br>  <code>ps -ef | grep tomcat | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -s 9</code></li>
</ul>
</li>
<li><p>临时修改网卡 eth0 上第一个 ip 地址<br>  <code>ifconfig eth0 192.168.1.104</code><br>  <a target="_blank" rel="noopener" href="http://blog.csdn.net/hzhsan/article/details/44677867">修改网卡 eth0 上第二个 ip 地址</a><br>  <code>ifconfig eth0:1 192.168.2.101</code><br>  配置当前主机的 ip 为 192.168.1.101，子网掩码为 255.255.255.0<br>  <code>ifconfig eth0 192.168.1.101 netmask 255.255.255.0 up</code><br>  开启/关闭网卡混杂模式<br>  <code>ifconfig eth0 promisc</code><br>  删除 eth0 上的默认路由<br>  <code>route del default eth0</code><br>  添加默认路由<br>  <code>route add default gw 192.168.1.1</code><br>  配置当前主机的默认网关为 192.168.1.1<br>  <code>route add default gw 192.168.1.1</code></p>
</li>
<li><p>查看当前主机的 mac 地址<br>  <code>ifconfig -a | grep -i hw</code></p>
</li>
<li><p>OpenSSL</p>
<ul>
<li>使用 OpenSSL 生成自签名证书及私钥(无 PEM pass phrase)<br>  <code>openssl req -nodes -new -x509 -keyout key.pem -out cert.crt</code><br>  <font color=grey>参数 “-nodes” 表示生成的私钥不需要加密，即无需输入无 PEM pass phrase</font></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xcloudbiz/articles/5523815.html">创建自签名的CA证书，及使用CA签发证书</a> <ol>
<li>创建自签名根证书密钥 ca.key、证书 ca.crt<br> <code>openssl req -new -days 3650 -x509 -keyout ca.key -out ca.crt -subj &quot;/C=CN/ST=JiangSu/L=NanJing/O=MyCompany Corp./emailAddress=admin@mycompany.com&quot;</code></li>
<li>创建服务器证书密钥 server.key<br> <code>openssl genrsa -out server.key 2048</code></li>
<li>创建服务器证书的申请文件 server.csr(Certificate Signing Request)<br> <code>openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/ST=JiangSu/L=NanJing/O=MyCompany Corp./CN=127.0.0.1/emailAddress=admin@mycompany.com&quot;</code><br> <font color=grey>其中 CN(Common Name) 为 “127.0.0.1” (服务器主机名)，即 web 服务访问的域名(如 “<a target="_blank" rel="noopener" href="http://www.microsoft.com&quot;),若填写不正确,浏览器会报告证书无效/">www.microsoft.com&quot;)，若填写不正确，浏览器会报告证书无效</a></font></li>
<li>使用 CA 证书签发自当前日期起有效期为期两年的服务器证书 server.crt<br> <code>openssl x509 -req -days 365 -sha256 -extensions v3_req -CA ca.crt -CAkey ca.key -CAserial ca.srl -CAcreateserial -in server.csr -out server.crt</code><br> <font color=grey>参数 “-sha256” 表示使用 sha256 签名算法，参数 “-extensions v3_req” 表示需要生成 v3 版的证书</font></li>
</ol>
</li>
<li>使用 OpenSSL 生成私钥文件 key.pem (2048位)<br>  <code>openssl genrsa -out key.pem 2048</code><br>  根据私钥文件生成自签名证书 cert.pem<br>  <code>openssl req -new -x509 -key key.pem -out cert.pem</code></li>
<li>将证书文件 server.crt 和证书密钥文件 server.key 合并成证书安装包 server.pfx<br>  <code>openssl pkcs12 -export -in server.crt -inkey server.key -out server.pfx</code></li>
<li>对字符串进行编码解码、加密解密<ul>
<li>对字符串 “hello, world” 进行 base64 编码<br>  <code>openssl base64 &lt;&lt;&lt; &quot;hello, world&quot;</code>  </li>
<li>对字符串 “hello, world” 进行 aes 加密，使用密钥 123，输出结果以 base64 编码格式给出<br>  <code>echo hello, world | openssl aes-128-cbc -k 123 -base64</code><br>  对以上结果进行解密处理<br>  <code>echo U2FsdGVkX18ynIbzARm15nG/JA2dhN4mtiotwD7jt4g= | openssl aes-128-cbc -d -k 123 -base64</code></li>
<li>对字符串 “hello, world” 进行 aes-128-cbc 加密，使用密钥 “123”、初始化向量 “123”<br>  <code>openssl aes-128-cbc -iv &quot;123&quot; -k &quot;123&quot; &lt;&lt;&lt; &quot;hello, world&quot;</code><br>  对字符串 “hello, world” 进行 aes-128-cbc 加密，输出结果以 base64 编码格式给出（需要手动输入密钥，如 “123”）<br>  <code>openssl aes-128-cbc &lt;&lt;&lt; &quot;hello, world&quot; | openssl base64</code><br>  对以上结果进行解密处理（需要手动输入密钥，与加密密钥一致，如 “123”）<br>  <code>openssl base64 -d &lt;&lt;&lt; &quot;U2FsdGVkX1+oPWAlmoa6dn4c5ePWw9zG8MaZ0YCblq4=&quot; | openssl aes-128-cbc -d</code></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/AloneSword/p/3480115.html">使用 OpenSSL 编码解码文件</a><br>  将文件 hello.txt 编码为 base64 格式，并输出到文件 hello.base64.txt 中<br>  <code>openssl base64 -in hello.txt -out hello.base64.txt</code><br>  使用 base64 解码文件 hello.base64.txt<br>  <code>openssl base64 -d -in hello.base64.txt -out hello.txt</code><br>  对文件 hello.txt 进行 md5 摘要计算<br>  <code>openssl md5 -in hello.txt</code></li>
<li>使用 AES 算法加密文件<br>  使用 aes-256-ecb 加密算法加密文件 a.txt 并输出到文件 a.ecb.txt 中<br>  <code>openssl enc -aes-256-ecb -in a.txt -out a.ecb.txt -e</code><br>  使用 aes-256-ecb 加密算法解密文件 a.ecb.txt 并输出到文件 a.ecb.d.txt 中<br>  <code>openssl enc -aes-256-ecb -in a.ecb.txt -out a.ecb.d.txt -d</code><br>  使用 aes-256-cbc 加密算法加密文件 a.bmp 并输出到文件 a.cbc.bmp 中<br>  <code>openssl enc -aes-256-cbc -in a.bmp -out a.cbc.bmp</code></li>
<li>使用 RSA 算法加密解密文件<ol>
<li>生成密钥的长度为 1024 位的私钥文件 pri_key.pem<br> <code>openssl genrsa -out pri_key.pem 1024</code></li>
<li>从私钥文件 pri_key.pem 中提取公钥文件 pub_key.pem<br> <code>openssl rsa -in pri_key.pem -pubout -out pub_key.pem</code></li>
<li>使用公钥文件 pub_key.pem 加密文件 a.txt<br> <code>openssl rsautl -encrypt -in a.txt -inkey pub_key.pem -pubin -out a.e.txt</code></li>
<li>使用密钥文件 pri_key.pem 解密文件 a.e.txt<br> <code>openssl rsautl -decrypt -in a.e.txt -inkey pri_key.pem -out a.d.txt</code></li>
</ol>
</li>
<li>证书转换、导入导出  <ul>
<li>PKCS12 转换为 PEM<ul>
<li>导出私钥<br>  <code>openssl pkcs12 -in client.p12 -passin pass:123456 -passout pass:123456 -nocerts -out client.pri.pem</code></li>
<li>导出证书<br>  <code>openssl pkcs12 -in client.p12 -passin pass:123456 -nokeys -out client.pub.pem</code></li>
</ul>
</li>
<li>PEM 转换为 PKCS12<br>  <code>openssl pkcs12 -export -in client.pub.pem -inkey client.pri.pem -out client.p12 -name client -passin pass:123456 -passout pass:123456</code></li>
<li>JKS 转换为 PKCS12<br>  <code>keytool -importkeystore -srcstoretype JKS -srckeystore client.jks -srcstorepass 123456 -srcalias client -srckeypass 123456 -deststoretype PKCS12 -destkeystore client.p12 -deststorepass 123456 -destalias client -destkeypass 123456 -noprompt</code></li>
<li>PKCS12 导出至 JKS<br>  <code>keytool -importkeystore -srckeystore client.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias client -deststorepass 123456 -destkeypass 123456 -destkeystore client.jks</code><blockquote>
<ul>
<li><a href="tomcat.md#keytool">使用 keytool 生成证书</a></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>使用 openssl 生成 alipay 商户公私钥文件（merchant_private_key_pkcs8.pem、alipay_public_key.pem）<ol>
<li>生成（商户）私钥<br> <code>openssl genrsa -out merchant_private_key.pem 2048</code></li>
<li>Java 开发者需要将私钥转换成 PKCS8 格式<br> <code>openssl pkcs8 -topk8 -inform PEM -in merchant_private_key.pem -outform PEM -nocrypt -out merchant_private_key_pkcs8.pem</code></li>
<li>生成（应用）公钥<br> <code>openssl rsa -in merchant_private_key.pem -pubout -out app_public_key.pem</code></li>
</ol>
</li>
<li>使用 openssl 查看网站证书信息<br>  <code>openssl s_client -showcerts -connect www.baidu.com:443 &lt; /dev/null</code></li>
<li><a target="_blank" rel="noopener" href="https://jamielinux.com/docs/openssl-certificate-authority/">使用 openssl 生成 ca 证书、签发中间 ca 证书、签发证书</a>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root ca certificate</span></span><br><span class="line">openssl genrsa -out ca.key 4096</span><br><span class="line">openssl req -new -x509 -days 7300 -key ca.key -subj <span class="string">&quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=Sunke Root CA&quot;</span> -out ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># intermediate ca certificate</span></span><br><span class="line">openssl req -newkey rsa:2048 -nodes -keyout intermediate.key -subj <span class="string">&quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=Sunke Intermediate CA&quot;</span> -out intermediate.csr</span><br><span class="line">openssl x509 -sha256 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">&quot;basicConstraints=critical,CA:true&quot;</span>) -days 3650 -<span class="keyword">in</span> intermediate.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out intermediate.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># server certificate (for multiple domains or ips, change subjectAltName to: DNS:example.com,DNS:www.example.com,IP:192.168.1.100)</span></span><br><span class="line">openssl req -newkey rsa:2048 -nodes -keyout server.key -subj <span class="string">&quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=www.example.com&quot;</span> -out server.csr</span><br><span class="line"><span class="comment">#openssl x509 -sha256 -req -extfile &lt;(printf &quot;subjectAltName=DNS:www.example.com&quot;) -days 365 -in server.csr -CA intermediate.crt -CAkey intermediate.key -CAcreateserial -out server.crt</span></span><br><span class="line">openssl x509 -sha256 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">&quot;subjectAltName=DNS:www.example.com,DNS:localhost,IP:127.0.0.1,IP:192.168.1.101&quot;</span>) -days 365 -<span class="keyword">in</span> server.csr -CA intermediate.crt -CAkey intermediate.key -CAcreateserial -out server.crt <span class="comment"># visit with url https://www.example.com or https://localhost or https://127.0.0.1 or https://192.168.1.101</span></span><br><span class="line">cat server.crt intermediate.crt ca.crt &gt; server.b.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># deploy server.key server.b.crt</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实现 /etc/shadow 中的密钥算法（详细请参考 <code>man crypt</code>）加密密码</p>
<ul>
<li>OpenSSL passwd 只支持基于 MD5 的加密算法（”xxxxxxxx” 为盐值，”password” 为密码明文，其结果应为 “$1$xxxxxxxx$UYCIxa628.9qXjpQCjM4a.”<br>）<br>  <code>openssl passwd -1 -salt &#39;xxxxxxxx&#39; &#39;password&#39;</code></li>
<li>使用 python 的 crypt 模块可以使用所有加密算法  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypt</span><br><span class="line"><span class="keyword">assert</span> crypt.crypt(<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;$6$Sguvrc9/&#x27;</span>) == <span class="string">&#x27;$6$Sguvrc9/$657bKmUBEpGUplcKgDhd3UOTy7r71/da6upxGkf1jvX4j22flk8av8oM8IjL2ztxk5xQDKmV3M2Ea5QfcA/6Y0&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;$6$Sguvrc9/&#x27; 表示使用基于 SHA-512 的加密算法和盐值 &#x27;Sguvrc9/&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>iptables 防火墙</p>
<ul>
<li>创建规则，将所有通过本机的源地址在 10.0.1.* 网段（网卡接口 1，如 eth0）的数据包转发到 10.0.2.* 网段（网卡接口 2，如 eth1）上，可用作网关不同网络之间的转发<br>  <code>iptables -I FORWARD -s 10.0.1.0/24 -d 10.0.2.0/24 -j ACCEPT</code><br>  参数 -D 表示删除该规则<br>  <code>iptables -D FORWARD -s 10.0.1.0/24 -d 10.0.2.0/24 -j ACCEPT</code></li>
<li>删除规则<ol>
<li>列出 INPUT 链所有规则<br> <code>iptables -L INPUT --line-numbers</code></li>
<li>删除 INPUT 链规则行号为 3 的规则<br> <code>iptables -D INPUT 3</code></li>
</ol>
</li>
<li>端口转发，将 422 端口的包转发到 22 端口<br>  <code>iptables -t nat -A PREROUTING -p tcp -d 192.168.1.37 --dport 422 -j DNAT --to 192.168.1.37:22</code></li>
</ul>
</li>
</ul>
<h2 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h2><ul>
<li><p>从网络上下载文件<br>  <code>wget http://xxx/xxx.tar.gz</code><br>  断点续传<br>  <code>wget -c http://xxx/xxx.tar.gz</code><br>  从 https 站点下载文件<br>  <code>wget https://102.alibaba.com/downloadFile.do?file=1516614343703/AliDouble11.pdf --no-check-certificate</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/gbyukg/p/3326825.html">使用 curl</a> 下载单个文件，默认将输出打印到标准输出中(stdout)中<br>  <code>curl http://www.centos.org</code><br>  <code>curl -k https://www.baidu.com</code><br>  参数 “-s” 表示不显示下载进度信息<br>  <code>curl -s http://www.baidu.com</code><br>  将文件下载到本地并命名为 mygettext.html（参数 “-o” 表示将文件保存为命令行中指定的文件名的文件中）<br>  <code>curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html</code><br>  将文件保存到本地并命名为 gettext.html（参数 “-O” 表示使用 URL 中默认的文件名保存文件到本地）<br>  <code>curl -O http://www.gnu.org/software/gettext/manual/gettext.html</code><br>  “–retry 3” 表示失败重试次数为 3 次，“–retry-delay 3” 表示失败重试间隔时间为 3 秒<br>  <code>curl -v -s -k -O http://www.gnu.org/software/gettext/manual/gettext.html --retry 3 --retry-delay 3</code><br>  通过添加 -C 选项继续对该文件进行下载，已经下载过的文件不会被重新下载（即断点续传）<br>  <code>curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html</code><br>  参数 “-L” 表示自动跟踪 URL 重定向跳转<br>  <code>curl -k -O -s -L https://github.com/btraceio/btrace/releases/download/v1.3.11.1/btrace-bin-1.3.11.1.zip</code><br>  使用环境变量设置代理服务器  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:5888</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:5888</span><br><span class="line"></span><br><span class="line">curl -k <span class="string">&#x27;https://139.159.158.150:8443/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  上传 json 文件<br>  <code>curl http://localhost:8983/xxx --data-binary @/temp/userinfo.json -H &#39;Content-type:application/json&#39;</code><br>  <code>curl -k https://xxx -F &quot;files=@data.zip&quot; -H &quot;filename:data.zip&quot;</code><br>  上传 jpeg 文件<br>  <code>curl -F &quot;pic=@1.jpg;filename=1.jpg;type=image/jpeg&quot; -F &quot;username=zhangsan&quot; -F &quot;type=2&quot; http://127.0.0.1:8080/upload</code><br>  使用 post 方法提交 json 格式数据<br>  <del><code>curl -X POST -H &#39;Content-Type: application/json&#39; &#39;http://localhost:8983/xxx&#39; --data-binary &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code></del><br>  <code>curl -X POST -H &#39;Content-Type: application/json&#39; http://localhost:8983/xxx -d &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code><br>  <code>curl -X POST -H &#39;Content-Type: application/json&#39; -H &#39;userid: 0012345&#39; http://localhost:8983/xxx -d &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code><br>  自定义 Locale<br>  <code>curl -H &#39;Accept-Language:zh_CN&#39; &#39;http://localhost:8983/xxx&#39;</code><br>  <code>curl -H &#39;Accept-Language:en-us;q=0.8,zh-cn&#39; http://localhost:8983/xxx</code></p>
</li>
<li><p>抓包并写入到文件 xxx.cap 中<br>  <code>tcpdump -i any port xxxx -s 0 -w xxx.cap</code><br>  抓包（直接显示 ip，不做 dns 翻译）<br>  <code>tcpdump -n</code><br>  监听本地 80 端口，抓包并写入到文件 http.cap 中（使用参数 “-s0”，指定抓包长度，防止解析时出现 “Packet size limited during capture: HTTP truncated”）<br>  <code>tcpdump port 80 -s0 -w http.cap</code><br>  抓包并写入到文件 file.pcap 中（抓取网卡 eth0 的 tcp 协议包，目的主机为 192.168.1.100:3306）<br>  <code>tcpdump -n -i eth0 tcp and host 192.168.1.100 and port 3306 -w file.pcap</code><br>  抓包并写入到文件 a.cap 中<br>  <code>tcpdump -n -w a.cap</code><br>  从文件 a.cap 中读取抓包数据<br>  <code>tcpdump -nX -r a.cap</code><br>  抓包所有与本机 1935 端口通信的数据包，并记录到 rtmp.log 中<br>  <code>tcpdump -nX port 1935 &gt; rtmp.log</code><br>  参数 -i 指定监听的网卡，如 eth、lo（可用于抓取本地包，即 127.0.0.1）<br>  <code>tcpdump -i lo port 8080</code></p>
</li>
<li><p>使用文字式网页浏览器打开网页 archive.ubuntu.com<br>  <code>w3m archive.ubuntu.com</code></p>
</li>
<li><p>发送消息/广播<br>  <code>echo &quot;hello, world&quot; | wall</code><br>  向指定用户 “root”、指定终端 “pts/9” 发送消息<br>  <code>write root pts/9</code></p>
</li>
<li><p>连接 ftp<br>  <code>sftp -o Port=20022 username@192.168.1.1</code></p>
</li>
<li><p>使用 sqlplus 连接 oracle 数据库<br>  <code>sqlplus sysdb/sys_12dagd@10.137.15.11:1526/mdspdb</code>   </p>
</li>
<li><p>使用 netcat 监听 TCP 的 3452 端口，并将镜像写入文件 cyqimage.dd<br>  <code>nc -l -p 3452 &gt; myimage.dd</code></p>
</li>
<li><p>使用 netcat 循环监听本地 80 端口，并响应 index.html 内容<br>  <code>while true; do nc -l -p 80 &lt; index.html; done</code><br>  使用 netcat 监听本地 UDP 协议的 8080 端口，其中参数 “-w1” 表示只接收一行消息，参数 “-u” 表示使用 UDP 协议<br>  <code>nc -u -w1 -l -p 8080</code><br>  使用 netcat 向本机的 8080 端口发送（一行）UDP 消息 “hello”<br>  <code>echo &quot;hello&quot; | nc -u -w1 127.0.0.1 8080</code><br>  向本机的 8080 端口发送 UDP 消息 “hello”<br>  <code>echo &quot;hello&quot; &gt; /dev/udp/localhost/8080</code></p>
</li>
<li><p>查询域名信息<br>  <code>whois www.baidu.com</code><br>  查询域名信息，指定端口查询<br>  <code>whois -p 80 www.baidu.com</code></p>
</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul>
<li><p>显示当前 shell 进程号<br>  <code>echo $$</code></p>
</li>
<li><p>在命令结尾处添加 <code>&amp;</code>，表示在后台运行命令（即进程在后台运行，Control + C 不会结束该进程，关闭 bash 时结束该进程）<br>  <code>python server.py &amp;</code><br>  在命令的开头加一个 <code>nohup</code>，表示忽略所有的挂断信号，如果当前 bash 关闭，则当前进程会挂载到 init 进程下，成为其子进程，这样即使退出当前用户，命令仍然在后台运行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup python server.py &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用追加模式（&quot;&gt;&gt;&quot;），可方便动态清空 out 日志内容（`cat /dev/null &gt; srv.out`）。否则无非释放 out 文件磁盘空间，见 https://zhidao.baidu.com/question/1821419994894225548.html</span></span><br><span class="line">nohup python server.py &gt;&gt; srv.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看后台执行的程序<br>  <code>jobs</code><br>  根据 jobs 命令查询的结果，唤起后台程序，如唤起序号为 2 的后台程序<br>  <code>fg 2</code></li>
</ul>
</li>
<li><p>编译、链接</p>
<ul>
<li>自动化编译，需先切换目录至 Makefile 所在目录（即项目根目录），再执行以下命令<br>  <code>make</code></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yinjiabin/article/details/7731817">使用gcc/g++编译、链接</a><ul>
<li>编译、链接当前目录下所有 “*.c” 文件，并使用用宏定义 “DEBUG” 进行条件编译，生成可执行文件 “main”<br>  <code>gcc *.c -DDEBUG -o main</code></li>
<li>编译&amp;链接为可执行文件<ul>
<li>编译、链接单个源文件 “main.c” 为可执行文件，默认生成可执行文件 “a”<br>  <code>gcc main.c</code></li>
<li>编译、链接单个源文件 “main.c” 为可执行文件，指定生成可执行文件 “main”<br>  <code>gcc main.c -o main</code><br>  “-static” 表示静态编译（即将动态库的函数和所依赖的任何的东西，都编译进本程序中，因此编译好后，文件会非常大，但是运行时不需要依赖任何动态库）<br>  <code>gcc -static main.c -o main</code></li>
<li>编译、链接多个源文件 “main.c”、”test.c”为可执行文件 “main”<br>  <code>gcc main.c test.c -o main</code></li>
</ul>
</li>
<li>编译、链接、调试<ol>
<li>编译、链接<br> <code>gcc -g main.c -o main</code></li>
<li>调试运行<br> <code>gdb main</code></li>
</ol>
</li>
<li>编译、链接、运行程序<ol>
<li>编译<br> <code>gcc -c main.c -o main.o</code></li>
<li>链接<br> <code>gcc main.o -o main</code><br> <del>将多个目标文件(“main.o”、”app.o”)链接为可执行文件 “main”<br> <code>gcc main.o app.o -o main</code></del></li>
<li>运行<br> <code>./main</code></li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_69e96b3701010881.html">编译链接动态库、静态库并调用</a><ul>
<li>编译 “func.c” 成动态链接库文件 “libfunc.so”<br>  <code>gcc -fPIC -shared func.c -o libfunc.so</code><br>  链接 “func1.o”、”func2.o” 成动态链接库文件 “libfunc.so”<br>  <code>gcc -o libfunc.so -fPIC -shared func1.o func2.o</code></li>
<li>链接 “func1.o”、”func2.o” 成静态链接库文件 “libfunc.a”<br>  <code>ar rc libfunc.a func1.o func2.o</code></li>
<li>编译链接 “main.c”，其中 “-lfunc” 中的 “func” 是指寻找当前目录下动态连接库 “libfunc.so”（隐含的命名规则：在给出的名字前面加上 lib，后面加上.so 来确定库的名称）<br>  <code>gcc -L. -lfunc main.c -o main</code></li>
</ul>
</li>
</ul>
</li>
<li>其他<br>  生成汇编代码 hello.s<br>  <code>gcc -S hello.c</code><br>  将汇编代码 hello.s 编译成可执行文件 hello<br>  <code>gcc hello.s -o hello</code></li>
</ul>
</li>
<li><p>使用 script 录制终端会话中所有输入输出结果，并保存时序信息至文件 “record.timing”，保存命令信息至文件 “record.script”（命令行提示 “Script started, file is record.script” 后开始录制，输入 “exit” 或键入 “Ctrl + D” 后提示 “Script done, file is record.script” 结束录制）<br>  <code>script -t 2&gt; record.timing record.script</code><br>  使用 scriptreplay 重放终端会话中所有输入输出结果<br>  <code>scriptreplay record.timing record.script</code></p>
</li>
<li><p>使用 qemu 启动一个虚拟机，内存为 128 mb，镜像为 dsl.iso<br>  <code>qemu -L . -m 128 -cdrom dsl.iso -enable-audio -localtime -user-net</code>  </p>
<blockquote>
<p>使用 qemu-img 创建一个虚拟磁盘<br><code>qemu-img create -f vhdx vdisk.vhdx 1G</code></p>
</blockquote>
</li>
<li><p>执行 shell 脚本</p>
<ul>
<li><p>fork 方式（由当前进程创建一个子进程）<br>  <code>./hello.sh</code></p>
</li>
<li><p>source 方式（不另外创建子进程，而是在当前的的 Shell 环境中执行）（可用于在脚本中集中设置环境变量，如引用 hello.sh 中的定义的环境变量）<br>  <code>source ./hello.sh</code>  </p>
<blockquote>
<p>该命令通常用命令 “.” 来替代<br>如：<code>source .bash_rc</code> 与 <code>. .bash_rc</code> 是等效的</p>
</blockquote>
</li>
<li><p>exec 方式（不另外创建子进程，但是会终止当前的 shell 执行）<br>  <code>exec ./hello.sh</code></p>
</li>
</ul>
</li>
<li><p>使用 python 正则查找所有 /etc/sudoers 中引用的 shell 脚本文件，并计算各脚本文件的 md5 值<br>  <code>python -c &quot;import re; print &#39; &#39;.join(re.compile(&#39;/[^,\s]+\.sh&#39;).findall(open(&#39;/etc/sudoers&#39;).read())).replace(&#39;\&#39;&#39;, &#39;&#39;);&quot; | xargs md5sum</code></p>
</li>
<li><p>执行命令<br>  <code>eval &quot;echo hello&quot;</code><br>  <code>exec echo hello</code> # 只能在脚本中使用</p>
</li>
<li><p>生成随机数</p>
<ul>
<li>随机生成 10 个字符的字符串<br>  <code>tr -dc &#39;A-Za-z0-9!?%=&#39; &lt; /dev/urandom | head -c 10</code><br>  <code>tr -cd &#39;[:alnum:]&#39; &lt; /dev/urandom | fold -w10 | head -n1</code><br>  <font color=grey># [:alnum:] 表示匹配当前归类中的数字、大写和小写字母字符</font></li>
<li>使用 OpenSSL 随机生成 10 个字节，并将其转换为十六进制数<br>  <code>openssl rand -hex 10</code><br>  随机生成 8 个字节，并将其转换为 base64 编码<br>  <code>openssl rand -base64 8</code>  </li>
</ul>
</li>
<li><p>格式化打印到控制台<br>  <code>printf &quot;hello, %5s&quot; &quot;hello&quot;</code><br>  <code>printf &quot;\e[1;31;40mRed\e[m&quot;</code><br>  <code>echo -e &quot;\e[1;31;40mRed\e[m&quot;</code></p>
<blockquote>
<p>终端的字符颜色由转义序列（Escape Sequence）控制，是文本模式下的系统显示功能，与具体语言无关<br>通过转义序列设置终端显示属性时，可采用格式：\033[ Param {;Param;…}m 或 \e[ Param {;Param;…}m（其中，’\033[‘或’\e[‘引导转义序列，’m’表示设置属性并结束转义序列）<br>转义序列相关的常用参数如下（通过 man console_codes 命令可查看更多的参数描述）：</p>
<ul>
<li>显示：0(默认)、1(粗体/高亮)、22(非粗体)、4(单条下划线)、24(无下划线)、5(闪烁)、25(无闪烁)、7(反显、翻转前景色和背景色)、27(无反显)</li>
<li>颜色：0(黑)、1(红)、2(绿)、3(黄)、4(蓝)、5(洋红)、6(青)、7(白)<br>前景色为 30+ 颜色值，如 31 表示前景色为红色；背景色为 40+ 颜色值，如 41 表示背景色为红色。</li>
</ul>
<p>如 <code>\e[1;31;40mRed\e[m</code> 或 <code>\033[1;31;40mRed\033[m</code> 表示使用粗体、前景色为红色、背景色为黑色显示字符串 Red</p>
</blockquote>
</li>
<li><p>在 ~/.ssh 目录下生成当前用户的密钥 id_rsa、公钥 id_rsa.pub<br>  <code>ssh-keygen -t rsa</code><br>  将公钥复制(替换或追加)到远程主机的 ~/.ssh 目录下的文件 authorized_keys，则远程主机信任当前主机用户，当前主机用户无需密码，可 ssh 直接登录远程主机<br>  <code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.101</code></p>
  <!-- `ssh-agent bash`
  `ssh-add id_rsa` --></li>
<li><p>使用 ssh 远程登录服务器<br>  <code>ssh 192.168.1.100</code><br>  通过私钥登录 ssh 服务器<br>  <code>ssh -i ~/.ssh/id_rsa root@192.168.1.200</code><br>  使用 ssh 向远程主机发送命令（设置主机信任后，可用于自动化脚本）  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name=$(date +%Y%m%d%H%M%S)</span><br><span class="line">ssh root@192.168.1.200 &lt;&lt; <span class="string">&quot;EOF&quot;</span></span><br><span class="line">mkdir ~/<span class="variable">$&#123;name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动登录远程主机 192.168.1.101，并登录该主机中的 docker 容器（参数 -t 表示强制伪终端分配，即使标准输入不是终端）</span></span><br><span class="line">ssh -t root@192.168.1.101 <span class="string">&quot;docker exec -it xxxxxxxx bash&quot;</span></span><br><span class="line">ssh -t root@192.168.1.101 <span class="string">&quot;docker exec -it \`docker ps | grep tomcat: | awk \&quot;&#123; print \\\\\$1 &#125;\&quot;\` /bin/bash&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录远程主机 192.168.1.101 并进入 /home 路径</span></span><br><span class="line">ssh -t root@192.168.1.101 <span class="string">&quot;cd /home; bash&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> mysql=<span class="string">&#x27;ssh -t root@192.168.1.101 mysql&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> kubectl()</span><br><span class="line">&#123;</span><br><span class="line">    ssh -t root@192.168.1.101 <span class="string">&quot;bash -ic \&quot;kubectl <span class="variable">$@</span>\&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看函数 kubectl 的定义</span></span><br><span class="line"><span class="comment"># type kubectl</span></span><br></pre></td></tr></table></figure>
<p>  保持连接:每60秒发送一次空包<br>  <code>ssh -o ServerAliveInterval=60 192.168.1.100</code></p>
</li>
<li><p>判断远程主机是否信任当前主机<br>  <code>ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no root@192.168.1.101 &quot;date&quot; &amp;&amp; echo $?</code><br>  结果返回 0 则信任，否则为不信任（如 255）</p>
</li>
<li><p>使用 ssh 进行端口转发</p>
<ul>
<li>监听本地8001端口（并登录远程主机192.168.1.102），将监听的tcp报文发送至（远程主机192.168.1.102的）localhost的8080端口，可用于正向端口转发<br>  <code>ssh -L 8001:localhost:8080 root@192.168.1.102</code></li>
<li>（通过主机192.168.1.102的ssh服务）将本机192.168.1.101的80端口转发至主机192.168.1.103的8080端口<br>  <code>ssh -L 192.168.1.101:80:192.168.1.103:8080 192.168.1.102</code><br>  <del><code>ssh -L 192.168.1.101:80:192.168.1.103:8080 192.168.1.101</code></del></li>
<li>（登录远程主机192.168.1.101并）监听远程主机的8001端口，将监听的tcp报文发送至本地localhost的8080端口，可用于反向端口转发<br>  <code>ssh -R 8001:localhost:8080 192.168.1.101</code></li>
<li>监听本地8001端口，（登录远程主机192.168.1.103）并动态开启端口，将监听的tcp报文通过该端口转发至目的服务器，可用于sockets代理服务器<br>  <code>ssh -D 8001 root@192.168.1.103</code></li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://dimke.gitee.io/2020/12/13/linux/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/12/13/javascript/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Javascript
          
        </div>
      </a>
    
    
      <a href="/2020/12/13/hello-world/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Hello World</div>
      </a>
    
  </nav>

  
   
  
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> Dim.Ke
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="https://portrait.gitee.com/uploads/avatars/user/110/332261_904243852_1578920294.jpg" alt="Dim.Ke"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/weixin.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>